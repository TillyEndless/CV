---
title: 【计组】第三章复习
published: 2024-11-10
description: '这一章有许多电路图（具体构造/封装电路），需要记忆并搞清楚布件功能。'
image: ''
tags: [notes]
category: '计组'
draft: false 
lang: ''
---
建议直接看：[咸鱼暄的计组笔记](https://xuan-insr.github.io/computer_organization/3_arithmetic/).

---
这一章节脉络很清晰，先梳理后复习记忆。

另外，这一章有许多电路图（具体构造/封装电路），需要记忆并搞清楚布件功能。

---
## 脉络：
1. ALU的功能进化
> 无符号加法 -> 与/或运算（1bit ALU）->减法 && Nor -> ALU串联（64-bit）-> 优化（64bit ALU最终版）-> 优化（加法加速）
2. 乘法/除法的进化设计
> - 乘法：无符号数（V1V2V3改进）-> 有符号数（Booth's Algorithm）
3. 浮点运算
>  IEEE 754 浮点表示
> 浮点加法&&乘法
> 浮点运算精确度
> - 四舍五入
> - 概念：三个extra bits

## 额外笔记
multiplicand 被乘数

multiplier 乘数


Booth’s Algorithm 是一种用于有符号二进制数乘法的算法，依赖于两个位的组合来决定如何处理被乘数。这两个位通常包括当前乘积的最低位和一个额外的位（通常是最低位的前一个位），它们共同决定操作步骤。算法的具体步骤如下：
	1.	初始化：假设乘数为 ￼、被乘数为 ￼，并设置一个额外的位 ￼ 为 0。根据所需的乘积位数，在乘积寄存器里初始化为 0。
	2.	循环操作：对乘数 ￼ 和附加位 ￼ 的最后两位进行以下判断，每次循环后将乘积右移一位。
	•	情况 1：如果最后两位是 01（即 ￼），表示乘数从正数过渡到负数，添加被乘数到乘积寄存器左半边。
	•	情况 2：如果最后两位是 10（即 ￼），表示乘数从负数过渡到正数，从乘积寄存器左半边中减去被乘数。
	•	情况 3：如果最后两位是 00 或 11，则不进行任何加减操作。
	3.	右移：每次操作后，右移乘积和乘数，确保符号位的保留，并更新 ￼ 以存储被移出的最低位。
	4.	重复：继续循环，直到经过位数长度次操作。

这样，Booth’s Algorithm 利用了两位判断来减少冗余操作，使得在处理正负过渡时能够高效完成加减法操作。


“Booth's Algorithm 也能应用于负数。”但是没看懂这里。

Addiction Fraction 部分相加减
这个是怎么相减的？取补码吗？怎么取？
