---
title: 【计组】第二章整理
published: 2024-10-29
description: ''
image: ''
tags: [计组]
category: ''
draft: false 
lang: ''
---
# 计组第二章
三种语言 高级语言、汇编语言、机器语言

## 目录
1. [章节理解维度](#章节理解维度)
2. [Outline](#Outline)
3. [Introduction](#Introduction)
4. [Arithmetic Operations](#Arithmetic-Operations)
5. [Operands](#Operands)
6. [Signed and Unsigned Numbers](#Signed-and-Unsigned-Numbers)
7. [Representing Instructions](#Representing-Instructions)
8. [Logic Operations](#Logic-Operations)
9. [Basic Blocks](#Basic-Blocks)
10. [Procedure and Stack Operations](#Procedure-and-Stack-Operations)
11. [Addressing and Linking](#Addressing-and-Linking)

---


**章节理解维度：**
1. 高级语言（C语言）————汇编语言
2. 汇编语言（汇编指令）————机器语言（机器码）
## Outline
* Introduction
* Operations of the computer hardware 
* Operands of the computer hardware
* Signed and a numbers
* Representing instructions in the computer
* Logical operations
* Instructions for making decision
* Supporting procedures in computer hardware
* Instruction addressing

## Introduction
 instruction set: RISC-V
 P6
 RISC VS CISC 对比表格
 P9
 Stored-program concept
 P12 
## Arithmetic Operations
## Oprands
*  RISC-V has a 32 × 64-bit register file
   *  Use for frequently accessed data
   *  64-bit data is called a “doubleword”
       *  32 x 64-bit general purpose registers x0 to x31
   *  32-bit data is called a “word” **4个字节一个”字“**
![截屏2024-10-17 15.39.38](/media/17291428769621/%E6%88%AA%E5%B1%8F2024-10-17%2015.39.38.png)
在函数调用中，寄存器 x0 是否被保留取决于调用约定。
![截屏2024-10-17 15.46.14](/media/17291428769621/%E6%88%AA%E5%B1%8F2024-10-17%2015.46.14.png)
![截屏2024-10-17 15.46.29](/media/17291428769621/%E6%88%AA%E5%B1%8F2024-10-17%2015.46.29.png)
![截屏2024-10-17 15.46.37](/media/17291428769621/%E6%88%AA%E5%B1%8F2024-10-17%2015.46.37.png)

* RISC-V does not require words to be aligned in 
memory
![截屏2024-10-17 16.24.54](/media/17291428769621/%E6%88%AA%E5%B1%8F2024-10-17%2016.24.54.png)
P19
base register & offset
![截屏2024-10-17 16.53.38](/media/17291428769621/%E6%88%AA%E5%B1%8F2024-10-17%2016.53.38.png)
P22 constant representation:
* constant oprands
* immediate operands

P23 Summary
![截屏2024-10-17 17.00.00](/media/17291428769621/%E6%88%AA%E5%B1%8F2024-10-17%2017.00.00.png)
## Signed and unsigned numbers
1. Unsigned Binary Integers: ![截屏2024-10-17 17.06.03](/media/17291428769621/%E6%88%AA%E5%B1%8F2024-10-17%2017.06.03.png)
2. 2s-Complement Signed Integers:![截屏2024-10-17 17.06.34](/media/17291428769621/%E6%88%AA%E5%B1%8F2024-10-17%2017.06.34.png)
![截屏2024-10-17 17.07.02](/media/17291428769621/%E6%88%AA%E5%B1%8F2024-10-17%2017.07.02.png)
    Signed Negation:Complement and add 1
    
P29 Sign Extension
![截屏2024-10-17 17.13.15](/media/17291428769621/%E6%88%AA%E5%B1%8F2024-10-17%2017.13.15.png)
lb,lbu.

## Representing Instructions
![截屏2024-10-17 18.33.41](/media/17291428769621/%E6%88%AA%E5%B1%8F2024-10-17%2018.33.41.png)
重点：寄存器的纯数字映射，RISC-V指令位宽，cpcode即为operation code（操作码）
**四种RISC-V指令格式：**
![截屏2024-10-17 18.40.33](/media/17291428769621/%E6%88%AA%E5%B1%8F2024-10-17%2018.40.33.png)
* Instruction fields
    * opcode: operation code
    * rd: destination register number
    * funct3: 3-bit function code (additional opcode)
    * rs1: the first source register number
    * rs2: the second source register number
    * funct7: 7-bit function code (additional opcode)
    
* I型指令：![截屏2024-10-17 18.49.16](/media/17291428769621/%E6%88%AA%E5%B1%8F2024-10-17%2018.49.16.png)
* S型指令：![截屏2024-10-17 18.50.02](/media/17291428769621/%E6%88%AA%E5%B1%8F2024-10-17%2018.50.02.png)
* RISC-V instruction encoding：![截屏2024-10-17 18.51.24](/media/17291428769621/%E6%88%AA%E5%B1%8F2024-10-17%2018.51.24.png)

## Logic Operations
![](/media/17291428769621/17291649815452.png)
shift left & right都是立即数指令？

![](/media/17291428769621/17297414321545.png)

 · 基址寻址：ld x19, 0(x10) # temp reg x19 = A[i]  其中的0（x10）就是基址寻址
 · 常见强制跳转：beq x0, x0, Loop 或 beq x0, x0, Exit

* jalr（Jump And Link Register）指令：
![](/media/17291428769621/17297537249051.png)
![](/media/17291428769621/17297540362309.png)![](/media/17291428769621/17297542048265.png)
* PC：当前正在执行的指令地址。一般情况下会自动递增4。**当遇到跳转（如 JAL、JALR）、分支或函数调用等指令时，PC 会被显式修改以跳转到其他位置执行。**
* 关于Address table:（以x6为table基地址为例）
![](/media/17291428769621/17297548751023.png)
![](/media/17291428769621/17297548872444.png)

* Basic Blocks（基本块）
    * 定义：一组没有分支（跳转）指令的连续指令序列
    ![](/media/17291428769621/17297573763056.png)
![](/media/17291428769621/17297574004820.png)






P40
UJ 和  ？ type 地址是双数的，舍去第一位（没有零位），加上第十二位，扩大范围。
P43 也是I型指令

jar jalr 无条件跳转？

**C和汇编转换**

P59
Procedure/function be used to structure programs：
* A stored subroutine that performs a specific task based on 
the parameters with which it is provided
    * easier to understand, allow code to be reused
* Six step
1. Place Parameters in a place where the procedure can access 
them
2. Transfer control to the procedure：jump to 
3. Acquire the storage resources needed for the procedure
4. Perform the desired task
5. Place the result value in a place where the calling program can 
access it 
6. Return control to the point of origin



堆栈：从高地址往低地址建设——>push:指针往下移——>进栈减，入栈加

leaf procedure：没有进一步的函数调用

理解🌰：
![截屏2024-10-17 14.25.44](/media/17291428769621/截屏2024-10-17 14.25.44.png)
建议学习从例子入手，从具象到理论更容易接受

p82 PC相对寻址
![截屏2024-10-17 14.52.43](/media/17291428769621/%E6%88%AA%E5%B1%8F2024-10-17%2014.52.43.png)
机器码：2000/2（去零位）
32位数对，考试错一位扣分，不要写漏数字！

P88 四种寻址方式：
![](/media/17291428769621/17295631673679.png)

P89 
查表判断指令是加法
rs2,rs1在汇编语言：不要写反！

P93
（数据）竞争——>解决：同步机制 原子操作（硬件支持）
atomic swap of register：一次读写打包
![](/media/17291428769621/17298416812708.png)
![](/media/17291428769621/17298417167825.png)
     
P94 load reserved：预约
rd：用于确认操作是否成功（不成功可能是因为数据改变/有其他进程在操作）
解决竞争的方法：![](/media/17291428769621/17295645628484.png)

注意理解两种方法的区别。

P96 linker链接器  loader
程序由很多头文件组成，用链接器链接![](/media/17291428769621/17295652222832.png)
根据object file header就能完成链接，而不需要扫描整个程序。

image file：镜像文件
动态链接：运行更多开销
动态静态：看需求
Lazy Linkage：也是动态链接
P102 右边是第二次（已经链接过了），左边是第一次（动态链接）![](/media/17291428769621/17295664311183.png)

间接跳转方式：不用修改主程序，跳转对应的表储存在内存里√
P103 Java虚拟机
P108
![](/media/17291428769621/17295671624850.png)
四个连续的mv意义？相当于堆栈。前两个mv：放进寄存器保护，避免被覆盖。后两个：拿出下一个交换的两个参数。
寄存器存储可以代替堆栈，除非寄存器spilling
bug：其实n没有被保护好，x11会被下一次循环改变。mv应该放在sort一开始（循环外面）
怎么改？

Smaller is faster：寄存器数量少，访问快


# 计组第四章
会画图！

黑色代表data，蓝色代表control：
![](/media/17291428769621/17295701339239.png)
必须使用RegWrite和MemWrite作为使能，防止Registers和DataMemory错误写入
Q：为什么要加MemRead，寄存器不用加RegRead？
A：因为memory读取很慢，能不读取时就不读取。（读取memory有风险，可能出现stop情况等待，延误时间）

## 数据通路
牢记前五个步骤：![](/media/17291428769621/17295711542439.png)
希望前五个时间尽可能相近。
modify PC:pc+4和branch